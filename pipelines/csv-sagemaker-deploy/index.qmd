---
title: Vetiver and Amazon SageMaker
description: "Using vetiver to version a model on Amazon SageMaker as an endpoint, and predict from it"
image: ../../images/csv-sagemaker-deploy.jpg
categories:
  - csv
  - vetiver
  - Amazon SageMaker
---

::: new
::: {.callout-note}
## Changes from standard

All changes from the [standard pipeline](../standard/index.qmd) is highlighted with a cranberry line to the right.
:::
:::

::: new

## Loading packages

We are using the tidymodels package to do the modeling, [embed](https://embed.tidymodels.org/) for target encoding, [pins](https://pins.rstudio.com/) for versioning,  [vetiver](https://vetiver.rstudio.com/) for version and deployment, and [smdocker](https://dyfanjones.r-universe.dev/smdocker) for deploying to SageMaker.

```{r}
#| label: setup
#| message: false
# install.packages("pak")
# pak::pak("tidymodels", "embed", "vetiver", "pins", "smdocker")
library(tidymodels)
library(embed)
library(vetiver)
library(pins)
library(smdocker)
```

:::

## Loading Data

We are using the standard `laxflights2022` data set described on the [data preparation](../../data-prep.qmd) page.

```{r}
#| label: loading-data
#| message: false
flights <- readr::read_csv(here::here("data/laxflights2022.csv"))

glimpse(flights)
```

downsampling for speed for now.

```{r}
flights <- slice_sample(flights, prop = 0.02) %>%
  arrange(time)
```

## Modeling

As a reminder, the modeling task we are trying to accomplish is the following:

> Given all the information we have, from the moment the plane leaves for departure. Can we predict the arrival delay `arr_delay`.

Our outcome is `arr_delay` and the remaining variables are predictors. We will be fitting a xgboost model as a regression model.

### Splitting Data

Since the data set is already in chronological order, we can create a time split of the data using `initial_time_split()`, this will put the first 75% of the data into the training data set, and the remaining 25% into the testing data set. 

```{r}
#| label: flights_split
set.seed(1234)

flights_split <- initial_time_split(flights, prop = 3/4)
flights_training <- training(flights_split)
```

Since we are doing hyperparameter tuning, we will also be creating a cross-validation split

```{r}
#| label: flights_folds
flights_folds <- vfold_cv(flights_training)
```

### Feature Engineering

We need to do a couple of things to make this data set work for our model. The datetime variable `time` needs to be transformed, as does the categorical variables `carrier`, `tailnum`, `origin` and `dest`.

From the `time` variable, the month and day of the week are extracted as categorical variables, then the day of year and time of day are extracted as numerics. The `origin` and `dest` variables will be turned into dummy variables, and `carrier`, `tailnum`, `time_month`, and `time_dow` will be converted to numerics with likelihood encoding.

```{r}
flights_rec <- recipe(arr_delay ~ ., data = flights_training) %>%
  step_novel(all_nominal_predictors()) %>%
  step_other(origin, dest, threshold = 0.025) %>%
  step_dummy(origin, dest) %>%
  step_date(time, 
            features = c("month", "dow", "doy"), 
            label = TRUE, 
            keep_original_cols = TRUE) %>%
  step_time(time, features = "decimal_day", keep_original_cols = FALSE) %>%
  step_lencode_mixed(all_nominal_predictors(), outcome = vars(arr_delay)) %>%
  step_zv(all_predictors())
```

### Specifying Models

We will be fitting a boosted tree model in the form of a [xgboost model](https://parsnip.tidymodels.org/reference/details_boost_tree_xgboost.html).

```{r}
xgb_spec <-
  boost_tree(
    trees = tune(),
    min_n = tune(),
    mtry = tune(),
    learn_rate = 0.01
  ) %>%
  set_engine("xgboost") %>%
  set_mode("regression")
```

```{r}
xgb_wf <- workflow(flights_rec, xgb_spec)
```


### Hyperparameter Tuning

```{r}
doParallel::registerDoParallel()

xgb_rs <- tune_grid(
  xgb_wf,
  resamples = flights_folds,
  grid = 10
)
```

We can visualize the performance of the different hyperparameter selections

```{r}
autoplot(xgb_rs)
```

and look at the top result

```{r}
show_best(xgb_rs, metric = "rmse")
```

### Fitting Final Model

Once we are satisfied with the modeling that has been done, we can fit our final model. We use `finalize_workflow()` to use the best hyperparameters, and `last_fit()` to fit the model to the training data set and evaluate it on the testing data set.

```{r}
xgb_last <- xgb_wf %>%
  finalize_workflow(select_best(xgb_rs, "rmse")) %>%
  last_fit(flights_split)
```

::: new

## Creating vetiver model

```{r}
v <- xgb_last %>%
  extract_workflow() %>%
  vetiver_model("flights_xgb")
v
```

## Version model with pins on Amazon SageMaker

We will version this model on [Amazon S3](https://aws.amazon.com/s3/) using the [pins](https://pins.rstudio.com/) package.

For the smoothest experience, we recommend that you authenticate using environment variables. The two variables you will need are `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.

::: {.callout-warning}
Depending on your S3 setup, you will need to use additional variables to connect. Please see <https://github.com/paws-r/paws/blob/main/docs/credentials.md> and this [pins issue](https://github.com/rstudio/pins-r/issues/608) for help if the following paragraphs doesn't work for you.
:::

::: {.callout-tip}
The function [usethis::edit_r_environ()](https://usethis.r-lib.org/reference/edit.html) can be very handy to open `.Renviron` file to specify your environment variables.
:::

You can find both of these keys in the same location. 

1. Open the [AWS Console](https://console.aws.amazon.com/)
1. Click on your username near the top right and select `Security Credentials`
1. Click on `Users` in the sidebar
1. Click on your username
1. Click on the `Security Credentials` tab
1. Click `Create Access Key`
1. Click `Show User Security Credentials`

Once you have those two, you can add them to your `.Renviron` file in the following format:

```markdown
AWS_SECRET_ACCESS_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxx
AWS_ACCESS_KEY_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

Note that you don't want to put quotes around the values. Once that is all done, we can create a board that connects to Amazon S3, and write our vetiver model to the board. Now that you have set up the environment variables, we can create a pins board. When using S3 you need to specify a bucket and its region. This cannot be done with Pins and has to be done beforehand.

```{r}
#| message: false
board <- board_s3(
  "tidymodels-pipeline-example",
  region = "us-west-1"
)
vetiver_pin_write(board, v)
```

Since we are using `vetiver_deploy_sagemaker()` which uses the {smdocker} package, we need to make sure that we have the right authetication and settings.

If you are working locally, you will likely need to explicitly set up your execution role to work correctly. Check out [Execution role requirements](https://dyfanjones.r-universe.dev/smdocker) in the smdocker documentation, and especially note that the bucket containing your vetiver model needs to be added as a resource in your IAM role policy.

Once we are properly set up, we can use `vetiver_deploy_sagemaker()`, it takes a `board`, the name of endpoint and the `instance_type` Look at the [Amazon SageMaker pricing](https://aws.amazon.com/sagemaker/pricing/) to help you decide what you need. Depending on your model, it will take a little while to run as it installs what it needs.

```{r}
#| eval: false
new_endpoint <- vetiver_deploy_sagemaker(
  board = board,
  name = "flights_xgb",
  instance_type = "ml.t2.medium"
)
```

## Make predictions from Connect endpoint

With the endpoint we can pass in some data set to predict with.

```{r}
#| eval: false
predict(
  new_endpoint,
  flights_training
)
```

```{r}
#| echo: false
tibble::tibble(
  .pred = c(-1.7894, -13.3206, -17.2753, -3.6661, 82.8237, 52.177, 10.7185, 8.0357, 58.146, 5.3933, rep(0, 2807)),
)
```

:::
